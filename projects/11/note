
~~~
HANDLING VARIABLES:
symbol table:

variable properties:
- name (identifier)
- type (int, char, boolean, class-name)
- kind (field, static, local, argument)
- scope (class-level, subroutine-level)


for methods, we need "this" as argument 0
class/subroutine level symbol tables can reset for each instance


variable declarations: just add it to the symbol table
variable usage: first look in the subroutine then class symbol table

nested scoping: use a linked list of symbol tables as follows:
head --> ... --> scope 2 --> scope 1 --> method --> class --> NULL


~~~
HANDLING EXPRESSIONS:

infix: humans
prefix: functional
postfix: stack

don't generate a parse tree as it will be HUGE
instead use the algorithm codeWrite(infix-exp)

CODE!!!!

~~~
HANDLING FLOW OF CONTROL:

while and if are challenging
need to done using goto, if-goto, label

IF: // labels are generated by the compiler
    compiled(expression)
    not
    if-goto L1
    compiled(statements1)
    goto L2
label L1
    compiled(statements2)
label L2
    compiled(statements2)
label L2
    ...

WHILE:
label L1
    compiled(expression)
    not
    if-goto L2
    compiled(statements)
    goto L1
label L2
...

~~~

HANDLING OBJECTS:
objects: this
arrays: that

push constant 8000
pop pointer 0
push/pop this 1     ; RAM[8001] = RAM[SP--]


~~~

HANDLING OBJECTS: CONSTRUCTION

on variable declaration, only symbol table is generated
call object constructors like normal subroutines and pop object variable
compiling constructors:


~~~

HANDLING OBJECTS: MANIPULATION

- ultimately the target machine is procedural
- the object is treated as first implicit argument

~~~

misc.

label generation

if / while: generate labels
problem: nesting

if [ 
    label LC
    LC = LC + 2
    
    if [ 
        label LC
        LC = LC + 2
        if [ ... ]
        LC = LC - 2
        label LC+1
    ]

    LC = LC - 2
    label LC+1
]

~~~
LC = 0

if [ 
    label 0
    LC = LC + 2
    
    if [ 
        label 2
        LC = LC + 2
        if [ ... ] // what is LC after this
        LC = LC - 2
        label LC+1
    ]

    LC = LC - 2
    label LC+1
]

